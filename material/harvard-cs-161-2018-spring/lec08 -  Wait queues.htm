<!DOCTYPE html>
<!-- saved from url=(0057)https://read.seas.harvard.edu/cs161-18/lectures/lecture8/ -->
<html lang="en" class="gr__read_seas_harvard_edu"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
    
    <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
    <link rel="stylesheet" href="./lec08 -  Wait queues_files/bootstrap.min.css" integrity="sha384-GJzZqFGwb1QTTN6wy59ffF1BuGJpLSa9DkKMp0DgiMDm4iYMj70gZWKYbI706tWS" crossorigin="anonymous">
    <link rel="stylesheet" href="./lec08 -  Wait queues_files/katex.min.css" integrity="sha384-9eLZqc9ds8eNjO3TmqPeYcDj8n+Qfa4nuSiGYa6DjLNcv9BtN69ZIulL9+8CqC9Y" crossorigin="anonymous">
    <link rel="stylesheet" href="./lec08 -  Wait queues_files/cs161.css">
    <title>Lecture 8 – CS 161 2018</title>
  <style type="text/css" id="af6420af-2236-4a55-b02a-712bf31c5c06">.c2e2a1a6-f224-4488-86ed-96fe160cbaa0 { position: relative !important; border-radius: 0.2em !important; padding: 0px !important; margin: 0px !important; }

.f773572a-041a-4433-9f9c-21508c5d3754 .ssh-close { position: absolute; left: -8px; top: -8px; width: 16px; height: 16px; z-index: 999; border: none; background: url("data:image/png;base64,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") no-repeat border-box; animation-duration: 275ms; animation-timing-function: ease-out; box-shadow: none; animation-name: ff1642a9-3941-4a90-bb41-974c93a7dc58; }

.f773572a-041a-4433-9f9c-21508c5d3754 .ssh-close:hover, .f773572a-041a-4433-9f9c-21508c5d3754 .ssh-close:focus { background-image: url("data:image/png;base64,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"); }

@media print {
  .f773572a-041a-4433-9f9c-21508c5d3754 { box-shadow: unset !important; -webkit-print-color-adjust: exact !important; }
}

@keyframes ff1642a9-3941-4a90-bb41-974c93a7dc58 { 
  0% { opacity: 0; transform: scale(0.6); }
  100% { opacity: 1; transform: scale(1); }
}

@keyframes e2d46e39-0c18-4233-b115-99ac6c4e84bb { 
  100% { opacity: 0; transform: scale(0.3); }
}

.f773572a-041a-4433-9f9c-21508c5d3754 { background-color: rgba(238, 238, 238, 0.8); color: rgb(170, 170, 170); font: inherit; box-shadow: rgb(238, 238, 238) 0px 0px 0.35em; text-shadow: none !important; }

.default-red-aa94e3d5-ab2f-4205-b74e-18ce31c7c0ce { box-shadow: rgb(255, 128, 128) 0px 0px 0.35em; background-color: rgba(255, 128, 128, 0.8) !important; color: rgb(0, 0, 0) !important; }

.default-orange-da01945e-1964-4d27-8a6c-3331e1fe7f14 { box-shadow: rgb(255, 210, 170) 0px 0px 0.35em; background-color: rgba(255, 210, 170, 0.8) !important; color: rgb(0, 0, 0) !important; }

.default-yellow-aaddcf5c-0e41-4f83-8a64-58c91f7c6250 { box-shadow: rgb(255, 255, 170) 0px 0px 0.35em; background-color: rgba(255, 255, 170, 0.8) !important; color: rgb(0, 0, 0) !important; }

.default-green-c4d41e0a-e40f-4c3f-91ad-2d66481614c2 { box-shadow: rgb(170, 255, 170) 0px 0px 0.35em; background-color: rgba(170, 255, 170, 0.8) !important; color: rgb(0, 0, 0) !important; }

.default-cyan-f88e8827-e652-4d79-a9d9-f6c8b8ec9e2b { box-shadow: rgb(170, 255, 255) 0px 0px 0.35em; background-color: rgba(170, 255, 255, 0.8) !important; color: rgb(0, 0, 0) !important; }

.default-purple-c472dcdb-f2b8-41ab-bb1e-2fb293df172a { box-shadow: rgb(255, 170, 255) 0px 0px 0.35em; background-color: rgba(255, 170, 255, 0.8) !important; color: rgb(0, 0, 0) !important; }

.default-grey-da7cb902-89c6-46fe-b0e7-d3b35aaf237a { box-shadow: rgb(119, 119, 119) 0px 0px 0.35em; background-color: rgba(119, 119, 119, 0.8) !important; color: rgb(255, 255, 255) !important; }</style></head>
  <body data-gr-c-s-loaded="true">

<nav class="navbar navbar-expand-lg navbar-light">
  <a class="navbar-brand" href="https://read.seas.harvard.edu/cs161-18/">CS 161 2018</a>
  <button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarSupportedContent" aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
    <span class="navbar-toggler-icon"></span>
  </button>
  <div class="collapse navbar-collapse" id="navbarSupportedContent">
    <ul class="navbar-nav mr-auto">
      
  <li class="nav-item dropdown">
    <a class="nav-link dropdown-toggle" href="https://read.seas.harvard.edu/cs161-18/lectures/lecture8/#" id="nav-dropdown-doc" role="button" data-toggle="dropdown" aria-haspopup="true" aria-expanded="false">
      Documentation
    </a>
    <div class="dropdown-menu" aria-labelledby="nav-dropdown-doc">
    
      <a class="dropdown-item" href="https://read.seas.harvard.edu/cs161-18/doc/cplusplus/">C++</a>
    
      <a class="dropdown-item" href="https://read.seas.harvard.edu/cs161-18/doc/lists/">Lists</a>
    
      <a class="dropdown-item" href="https://read.seas.harvard.edu/cs161-18/doc/memory-layout/">Memory layout</a>
    
      <a class="dropdown-item" href="https://read.seas.harvard.edu/cs161-18/doc/contexts/">Contexts</a>
    
      <a class="dropdown-item" href="https://read.seas.harvard.edu/cs161-18/doc/memory-iterators/">Memory iterators</a>
    
      <a class="dropdown-item" href="https://read.seas.harvard.edu/cs161-18/doc/spinlocks/">Spinlocks</a>
    
      <a class="dropdown-item" href="https://read.seas.harvard.edu/cs161-18/doc/synchronization-invariants/">Synchronization invariants</a>
    
      <a class="dropdown-item" href="https://read.seas.harvard.edu/cs161-18/doc/chickadeefs/">ChickadeeFS</a>
    
    </div>
  </li>

      
  <li class="nav-item">
    
      <a class="nav-link" href="https://read.seas.harvard.edu/cs161-18/schedule/">Schedule</a>
    
  </li>

      
  <li class="nav-item dropdown">
    <a class="nav-link dropdown-toggle" href="https://read.seas.harvard.edu/cs161-18/lectures/lecture8/#" id="nav-dropdown-psets" role="button" data-toggle="dropdown" aria-haspopup="true" aria-expanded="false">
      Problem sets
    </a>
    <div class="dropdown-menu" aria-labelledby="nav-dropdown-psets">
    
      <a class="dropdown-item" href="https://read.seas.harvard.edu/cs161-18/pset1/">Problem set 1</a>
    
      <a class="dropdown-item" href="https://read.seas.harvard.edu/cs161-18/pset2/">Problem set 2</a>
    
      <a class="dropdown-item" href="https://read.seas.harvard.edu/cs161-18/pset3/">Problem set 3</a>
    
      <a class="dropdown-item" href="https://read.seas.harvard.edu/cs161-18/pset4/">Problem set 4</a>
    
      <a class="dropdown-item" href="https://read.seas.harvard.edu/cs161-18/pset5/">Problem set 5</a>
    
    </div>
  </li>

      
  <li class="nav-item dropdown">
    <a class="nav-link dropdown-toggle" href="https://read.seas.harvard.edu/cs161-18/lectures/lecture8/#" id="nav-dropdown-lectures" role="button" data-toggle="dropdown" aria-haspopup="true" aria-expanded="false">
      Lectures
    </a>
    <div class="dropdown-menu" aria-labelledby="nav-dropdown-lectures">
    
      <a class="dropdown-item" href="https://read.seas.harvard.edu/cs161-18/lectures/lecture2/">Lecture 2</a>
    
      <a class="dropdown-item" href="https://read.seas.harvard.edu/cs161-18/lectures/lecture3/">Lecture 3</a>
    
      <a class="dropdown-item" href="https://read.seas.harvard.edu/cs161-18/lectures/lecture4/">Lecture 4</a>
    
      <a class="dropdown-item" href="https://read.seas.harvard.edu/cs161-18/lectures/lecture5/">Lecture 5</a>
    
      <a class="dropdown-item" href="https://read.seas.harvard.edu/cs161-18/lectures/lecture6/">Lecture 6</a>
    
      <a class="dropdown-item" href="https://read.seas.harvard.edu/cs161-18/lectures/lecture7/">Lecture 7</a>
    
      <a class="dropdown-item" href="https://read.seas.harvard.edu/cs161-18/lectures/lecture8/">Lecture 8</a>
    
      <a class="dropdown-item" href="https://read.seas.harvard.edu/cs161-18/lectures/lecture9/">Lecture 9</a>
    
      <a class="dropdown-item" href="https://read.seas.harvard.edu/cs161-18/lectures/lecture10/">Lecture 10</a>
    
      <a class="dropdown-item" href="https://read.seas.harvard.edu/cs161-18/lectures/lecture11/">Lecture 11</a>
    
      <a class="dropdown-item" href="https://read.seas.harvard.edu/cs161-18/lectures/lecture12/">Lecture 12</a>
    
      <a class="dropdown-item" href="https://read.seas.harvard.edu/cs161-18/lectures/lecture14/">Lecture 14</a>
    
      <a class="dropdown-item" href="https://read.seas.harvard.edu/cs161-18/lectures/lecture15/">Lecture 15</a>
    
      <a class="dropdown-item" href="https://read.seas.harvard.edu/cs161-18/lectures/lecture16/">Lecture 16</a>
    
      <a class="dropdown-item" href="https://read.seas.harvard.edu/cs161-18/lectures/lecture17/">Lecture 17</a>
    
      <a class="dropdown-item" href="https://read.seas.harvard.edu/cs161-18/lectures/lecture18/">Lecture 18</a>
    
      <a class="dropdown-item" href="https://read.seas.harvard.edu/cs161-18/lectures/lecture19/">Lecture 19</a>
    
      <a class="dropdown-item" href="https://read.seas.harvard.edu/cs161-18/lectures/lecture20/">Lecture 20</a>
    
      <a class="dropdown-item" href="https://read.seas.harvard.edu/cs161-18/lectures/lecture21/">Lecture 21</a>
    
      <a class="dropdown-item" href="https://read.seas.harvard.edu/cs161-18/lectures/lecture22/">Lecture 22</a>
    
      <a class="dropdown-item" href="https://read.seas.harvard.edu/cs161-18/lectures/lecture23/">Lecture 23</a>
    
      <a class="dropdown-item" href="https://read.seas.harvard.edu/cs161-18/lectures/lecture24/">Lecture 24</a>
    
      <a class="dropdown-item" href="https://read.seas.harvard.edu/cs161-18/lectures/lecture25/">Lecture 25</a>
    
      <a class="dropdown-item" href="https://read.seas.harvard.edu/cs161-18/lectures/papers/">Papers</a>
    
    </div>
  </li>

      
  <li class="nav-item dropdown">
    <a class="nav-link dropdown-toggle" href="https://read.seas.harvard.edu/cs161-18/lectures/lecture8/#" id="nav-dropdown-sections" role="button" data-toggle="dropdown" aria-haspopup="true" aria-expanded="false">
      Sections
    </a>
    <div class="dropdown-menu" aria-labelledby="nav-dropdown-sections">
    
      <a class="dropdown-item" href="https://read.seas.harvard.edu/cs161-18/sections/section1/">Section 1</a>
    
      <a class="dropdown-item" href="https://read.seas.harvard.edu/cs161-18/sections/section2/">Section 2</a>
    
      <a class="dropdown-item" href="https://read.seas.harvard.edu/cs161-18/sections/section3/">Section 3</a>
    
      <a class="dropdown-item" href="https://read.seas.harvard.edu/cs161-18/sections/section4/">Section 4</a>
    
      <a class="dropdown-item" href="https://read.seas.harvard.edu/cs161-18/sections/section5/">Section 5</a>
    
      <a class="dropdown-item" href="https://read.seas.harvard.edu/cs161-18/sections/section6/">Section 6</a>
    
    </div>
  </li>

    </ul>
  </div>
</nav>


<div class="container">
    <h1><a href="https://read.seas.harvard.edu/cs161-18/lectures/lecture8/">Lecture 8: Wait queues</a></h1>
    <div class="post">
        <h2 id="motivation">Motivation</h2>

<p>Scheduling is a fundamental kernel responsibility. Kernels strive to
efficiently and fairly divide all computer resources, including CPU, among
jobs according to OS policy. There’s a ton of effort in every real kernel to
do this—and all that work eventually boils down to efficiently and correctly
<em>putting tasks to sleep</em> and <em>waking them up again</em>.</p>

<p>Think of it this way. Processes often wait for external events. Your editor
waits for key presses; your browser waits for interactions (and/or
animations); web servers wait for network connections. Efficiency demands that
processes engaged only in waiting should use as little CPU as possible—ideally
zero.</p>

<p>A blocking system call informs the kernel that a process is waiting, since the
system call returns to its caller only when a specific external event (or
interruption) occurs. But in Chickadee so far, waiting processes take far more
than 0% CPU. Here’s a natural implementation of <code>sys_msleep</code>:</p>
<div class="highlight"><pre style="background-color:#f0f0f0;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c++" data-lang="c++"><span style="color:#007020;font-weight:bold">while</span> (<span style="color:#902000">long</span>(want_ticks <span style="color:#666">-</span> ticks) <span style="color:#666">&gt;</span> <span style="color:#40a070">0</span>) {
    yield();
}
</code></pre></div>
<p>This implementation <em>polls</em> by repeatedly checking whether the desired time
has arrived. The kernel task corresponding to the process remains runnable the
whole time! In the <code>p-testmsleep</code> process, the tasks corresponding to blocked
processes run more than a hundred thousand times. That wasted time would be
better spent on actual work.</p>

<h2 id="sleepwakeup">Sleep-wakeup</h2>

<p>We seek a coordination mechanism that allows a kernel task to block—to become
non-runnable—until a condition becomes true. Generalizing a little bit to
abstract “threads” rather than kernel tasks:</p>

<ul>
<li><p>Let <span class="math"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>x</mi></mrow><annotation encoding="application/x-tex">x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 0.43056em; vertical-align: 0em;"></span><span class="mord mathdefault">x</span></span></span></span></span> be some subset of program state. <span class="math"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>x</mi></mrow><annotation encoding="application/x-tex">x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 0.43056em; vertical-align: 0em;"></span><span class="mord mathdefault">x</span></span></span></span></span> can be as much as the whole
program or as little as a single integer.</p></li>

<li><p>A <em>sleeping thread</em> has blocked until a condition <span class="math"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>f</mi><mo>(</mo><mi>x</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">f(x)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord mathdefault" style="margin-right: 0.10764em;">f</span><span class="mopen">(</span><span class="mord mathdefault">x</span><span class="mclose">)</span></span></span></span></span> becomes true. It
is an error for the sleeping thread to remain blocked after <span class="math"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>f</mi><mo>(</mo><mi>x</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">f(x)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord mathdefault" style="margin-right: 0.10764em;">f</span><span class="mopen">(</span><span class="mord mathdefault">x</span><span class="mclose">)</span></span></span></span></span> becomes
true.</p></li>

<li><p>A <em>waking thread</em> is a thread that modifies <span class="math"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>x</mi></mrow><annotation encoding="application/x-tex">x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 0.43056em; vertical-align: 0em;"></span><span class="mord mathdefault">x</span></span></span></span></span> in a way that might cause
a sleeping thread to unblock and become runnable.</p></li>
</ul>

<p>The inherent difficulty of sleep–wakeup is that sleeping and waking threads
must synchronize. If they do not, a sleeping thread might remain blocked
forever! We’re worried about this interleaving of events, which is a classic
<em>lost wakeup</em> or <em>sleep–wakeup race</em>:</p>

<table>
<thead>
<tr>
<th>sleeping thread</th>
<th>waking thread</th>
</tr>
</thead>

<tbody>
<tr>
<td>computes f(x) == false;</td>
<td></td>
</tr>

<tr>
<td>decides to block;</td>
<td></td>
</tr>

<tr>
<td></td>
<td>modifies x so f(x) becomes true;</td>
</tr>

<tr>
<td></td>
<td>checks if any other thread is blocked (there are none);</td>
</tr>

<tr>
<td></td>
<td>does something else;</td>
</tr>

<tr>
<td>blocks forever;</td>
<td></td>
</tr>
</tbody>
</table>

<p>How to fix this? A lock, such as a spinlock, can prevent bad interleavings,
but blocking makes this bad interleaving tricky! Normally we’d associate <code>x</code>
(the shared state) with a lock, say <code>x_lock</code>, and place <code>lock</code> calls on entry
to the critical section and <code>unlock</code> calls after it:</p>

<table>
<thead>
<tr>
<th>sleeping thread</th>
<th>waking thread</th>
</tr>
</thead>

<tbody>
<tr>
<td><strong>locks <code>x_lock</code></strong>;</td>
<td></td>
</tr>

<tr>
<td>computes f(x) == false;</td>
<td></td>
</tr>

<tr>
<td>decides to block;</td>
<td></td>
</tr>

<tr>
<td></td>
<td><strong>tries to lock <code>x_lock</code></strong> (blocks…)</td>
</tr>

<tr>
<td>blocks forever, holding <code>x_lock</code>;</td>
<td></td>
</tr>
</tbody>
</table>

<p>This won’t work at all. It’s immoral to block while holding a lock. Doing so
can deadlock the system, as it will here: the waking thread never wakes up the
sleeping thread because the waking thread can’t acquire <code>x_lock</code>.</p>

<p>But moving “unlock <code>x_lock</code>” before the block point just recreates the
original synchronization problem.</p>

<table>
<thead>
<tr>
<th>sleeping thread</th>
<th>waking thread</th>
</tr>
</thead>

<tbody>
<tr>
<td><strong>locks <code>x_lock</code></strong>;</td>
<td></td>
</tr>

<tr>
<td>computes f(x) == false;</td>
<td></td>
</tr>

<tr>
<td>decides to block;</td>
<td></td>
</tr>

<tr>
<td><strong>unlocks <code>x_lock</code></strong>;</td>
<td></td>
</tr>

<tr>
<td></td>
<td><strong>locks <code>x_lock</code></strong>;</td>
</tr>

<tr>
<td></td>
<td>modifies x so f(x) becomes true;</td>
</tr>

<tr>
<td></td>
<td>checks if any other thread is blocked (there are none);</td>
</tr>

<tr>
<td>blocks (forever);</td>
<td></td>
</tr>

<tr>
<td></td>
<td><strong>unlocks <code>x_lock</code></strong>;</td>
</tr>

<tr>
<td></td>
<td>does something else;</td>
</tr>
</tbody>
</table>

<p>So we need a lock for synchronization; we <em>must not</em> hold the lock while
blocking; and we <em>must not</em> release the lock before blocking! What is to be
done?</p>

<h2 id="condition-variables">Condition variables</h2>

<p>In user-level programming, this problem is typically solved with
synchronization objects called <em>condition variables</em>. The magic of condition
variables is that they offer an <em>atomic</em> operation, <code>cond_wait</code>, that both
releases a lock and blocks the calling thread. Here’s how the running example
would work with <code>cond_wait</code>:</p>

<table>
<thead>
<tr>
<th>sleeping thread</th>
<th>waking thread</th>
</tr>
</thead>

<tbody>
<tr>
<td><strong>locks <code>x_lock</code></strong>;</td>
<td></td>
</tr>

<tr>
<td>computes f(x) == false;</td>
<td></td>
</tr>

<tr>
<td>decides to block;</td>
<td></td>
</tr>

<tr>
<td><strong>calls <code>cond_wait(&amp;x_cond, &amp;x_lock)</code></strong>;</td>
<td></td>
</tr>

<tr>
<td></td>
<td><strong>locks <code>x_lock</code></strong>;</td>
</tr>

<tr>
<td></td>
<td>modifies x so f(x) becomes true;</td>
</tr>

<tr>
<td></td>
<td><strong>calls <code>cond_signal(&amp;x_cond)</code></strong>, waking up the sleeping thread;</td>
</tr>
</tbody>
</table>

<p>Since <code>cond_wait</code> releases the lock and blocks in one atomic step, there is no
way for the waking thread to sneak in at the wrong place. Either the waking
thread runs entirely before the sleeping thread acquires the lock, or the the
waking thread runs entirely after <code>cond_wait</code>. And either run order has the
right result. If the waking thread runs first, the sleeping thread won’t
block; if the sleeping thread runs first, the waking thread will observe the
sleeping thread and wake it up.</p>

<p>But we’re programming a kernel. If we want a condition variable, we will have
to program it ourselves—and perhaps in kernel context a different abstraction
will be preferred.</p>

<h2 id="how-other-kernels-do-it">How other kernels do it</h2>

<p>OS/161, the previous CS 161 teaching kernel, uses this function:</p>
<div class="highlight"><pre style="background-color:#f0f0f0;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c"><span style="color:#902000">void</span> <span style="color:#06287e">wchan_sleep</span>(<span style="color:#007020;font-weight:bold">struct</span> wchan <span style="color:#666">*</span>wc, <span style="color:#007020;font-weight:bold">struct</span> spinlock <span style="color:#666">*</span>lk);</code></pre></div>
<p>which atomically blocks the current thread (a later call to <code>wchan_wake…(wc)</code>
will wake it) and releases the spinlock <code>lk</code>. Sound familar? This is a
condition-variable wait operation! In implementation, <code>wchan_sleep</code> calls a
more basic function, <code>thread_switch</code>, which handles all voluntary kernel
context switches. The need for atomic unlock-and-block infects that
foundational function too:</p>
<div class="highlight"><pre style="background-color:#f0f0f0;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c"><span style="color:#60a0b0;font-style:italic">/*
</span><span style="color:#60a0b0;font-style:italic"> * If NEWSTATE is S_SLEEP, the thread is queued on the wait channel
</span><span style="color:#60a0b0;font-style:italic"> * WC, protected by the spinlock LK. Otherwise WC and Lk should be
</span><span style="color:#60a0b0;font-style:italic"> * NULL.
</span><span style="color:#60a0b0;font-style:italic"> */</span>
<span style="color:#007020;font-weight:bold">static</span> <span style="color:#902000">void</span> <span style="color:#06287e">thread_switch</span>(threadstate_t newstate, <span style="color:#007020;font-weight:bold">struct</span> wchan <span style="color:#666">*</span>wc, <span style="color:#007020;font-weight:bold">struct</span> spinlock <span style="color:#666">*</span>lk);</code></pre></div>
<p>Since the foundational thread switching function uses <code>wchan</code>s, any blocking
primitive you think up must in OS/161 be expressed using <code>wchan</code>s.</p>

<p>The xv6 teaching operating system has a similar design, except that “wait
channels” are left undefined (they are opaque pointers).</p>
<div class="highlight"><pre style="background-color:#f0f0f0;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c"><span style="color:#60a0b0;font-style:italic">// Atomically release lock and sleep on chan.
</span><span style="color:#60a0b0;font-style:italic">// Reacquires lock when awakened.
</span><span style="color:#60a0b0;font-style:italic"></span><span style="color:#902000">void</span> <span style="color:#06287e">sleep</span>(<span style="color:#902000">void</span> <span style="color:#666">*</span>chan, <span style="color:#007020;font-weight:bold">struct</span> spinlock <span style="color:#666">*</span>lk);</code></pre></div>
<p>This resembles the FreeBSD operating system’s general sleep function,
<code>_sleep</code>. Like xv6 <code>sleep</code>, FreeBSD <code>_sleep</code> takes a <code>void* ident</code> (an opaque
identifier for a wait channel) and a <code>struct lock_object* lock</code>. But years of
use and feature development have added more stuff:</p>
<div class="highlight"><pre style="background-color:#f0f0f0;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c"><span style="color:#60a0b0;font-style:italic">/*
</span><span style="color:#60a0b0;font-style:italic"> * General sleep call.  Suspends the current thread until a wakeup is
</span><span style="color:#60a0b0;font-style:italic"> * performed on the specified identifier.  The thread will then be made
</span><span style="color:#60a0b0;font-style:italic"> * runnable with the specified priority.  Sleeps at most sbt units of time
</span><span style="color:#60a0b0;font-style:italic"> * (0 means no timeout).  If pri includes the PCATCH flag, let signals
</span><span style="color:#60a0b0;font-style:italic"> * interrupt the sleep, otherwise ignore them while sleeping.  Returns 0 if
</span><span style="color:#60a0b0;font-style:italic"> * awakened, EWOULDBLOCK if the timeout expires.  If PCATCH is set and a
</span><span style="color:#60a0b0;font-style:italic"> * signal becomes pending, ERESTART is returned if the current system
</span><span style="color:#60a0b0;font-style:italic"> * call should be restarted if possible, and EINTR is returned if the system
</span><span style="color:#60a0b0;font-style:italic"> * call should be interrupted by the signal (return EINTR).
</span><span style="color:#60a0b0;font-style:italic"> *
</span><span style="color:#60a0b0;font-style:italic"> * The lock argument is unlocked before the caller is suspended, and
</span><span style="color:#60a0b0;font-style:italic"> * re-locked before _sleep() returns.  If priority includes the PDROP
</span><span style="color:#60a0b0;font-style:italic"> * flag the lock is not re-locked before returning.
</span><span style="color:#60a0b0;font-style:italic"> */</span>
<span style="color:#902000">int</span> <span style="color:#06287e">_sleep</span>(<span style="color:#902000">void</span> <span style="color:#666">*</span>ident, <span style="color:#007020;font-weight:bold">struct</span> lock_object <span style="color:#666">*</span>lock, <span style="color:#902000">int</span> priority,
    <span style="color:#007020;font-weight:bold">const</span> <span style="color:#902000">char</span> <span style="color:#666">*</span>wmesg, sbintime_t sbt, sbintime_t pr, <span style="color:#902000">int</span> flags);</code></pre></div>
<p>All these operating systems implement sleep-wakeup by pushing the atomic
unlock-and-block step to the core of the operating system. But that’s not the
only way. Rather than <em>joining</em> unlocking and blocking into a single atomic
step, we can <em>separate</em> blocking into <em>two</em> steps, enqueuing and scheduling.
With blocking unpacked in this way, sleep–wakeup can be implemented with
less core scheduler involvement. Linux, and Chickadee, adopt this design,
using synchronization objects called <em>wait queues</em>.</p>

<h2 id="wait-queues">Wait queues</h2>

<p>Chickadee wait queues are used like this.</p>
<div class="highlight"><pre style="background-color:#f0f0f0;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c++" data-lang="c++">wait_queue waitq; ...
function_that_might_sleep(proc<span style="color:#666">*</span> p) { ...
    waiter w(p);
    <span style="color:#007020;font-weight:bold">while</span> (<span style="color:#40a070">1</span>) {
        w.prepare(<span style="color:#666">&amp;</span>waitq);
        <span style="color:#007020;font-weight:bold">if</span> (p should wake up) {
            <span style="color:#007020;font-weight:bold">break</span>;
        }
        w.block();
    }
    w.clear();
}
</code></pre></div>
<p>Here’s what these functions do.</p>

<ul>
<li><code>waiter::prepare(waitq)</code>—This function prepares the waiter to sleep
on the named wait queue, and implements the “enqueue” part of blocking.
Specifically, the function:

<ul>
<li>Locks the <code>waitq</code> data structure.</li>
<li>Sets <code>p-&gt;state_</code> to <code>proc::blocked</code>. This means the state is blocked
<em>even though the associated kernel task is running</em>!</li>
<li>Adds the <code>waiter</code> to a linked list of waiters associated with the <code>waitq</code>.</li>
<li>Unlocks the <code>waitq</code> data structure.</li>
</ul></li>
<li><code>waiter::clear()</code>—This function cleans up the waiter after the process has
woken up, by undoing the effect of any preceding <code>waiter::prepare</code>.
Specifically, the function:

<ul>
<li>Locks the <code>waitq</code> data structure.</li>
<li>Sets <code>p-&gt;state_</code> to <code>proc::runnable</code>.</li>
<li>Removes the <code>waiter</code> from the linked list, if it is currently linked.</li>
<li>Unlocks the <code>waitq</code> data structure.</li>
</ul></li>
<li><code>waiter::block()</code>—This function implements the “block” part of blocking.
Specifically, the function:

<ul>
<li>Calls <code>p-&gt;yield()</code>. If the process still has <code>state_ == blocked</code>, then
the process will block.</li>
<li>When the <code>yield</code> call returns, it calls <code>waiter::clear()</code> to clean up
the waiter.</li>
</ul></li>
</ul>

<p>It’s very important that interrupts be disabled throughout this whole
procedure, or an ill-timed timer interrupt could cause the kernel task to
block forever.</p>

<p>A wakeup function will often look like this:</p>
<div class="highlight"><pre style="background-color:#f0f0f0;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c++" data-lang="c++">wait_queue waitq; ...
<span style="color:#007020;font-weight:bold">auto</span> irqs <span style="color:#666">=</span> waitq.lock_.lock();
<span style="color:#007020;font-weight:bold">while</span> (<span style="color:#007020;font-weight:bold">auto</span> w <span style="color:#666">=</span> waitq.q_.pop_front()) {
    w<span style="color:#666">-&gt;</span>p_<span style="color:#666">-&gt;</span>wake();
}
waitq.lock_.unlock(irqs);
</code></pre></div>
<p>This code uses a new <code>proc::wake()</code> function, which should set the current
process’s state to <code>runnable</code> and enqueue it on the relevant <code>cpustate</code>’s run
queue. Here’s ours:</p>
<div class="highlight"><pre style="background-color:#f0f0f0;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c++" data-lang="c++"><span style="color:#007020;font-weight:bold">inline</span> <span style="color:#902000">void</span> proc<span style="color:#666">::</span>wake() {
    <span style="color:#007020;font-weight:bold">auto</span> irqs <span style="color:#666">=</span> cpus[cpu_].runq_lock_.lock();
    <span style="color:#007020;font-weight:bold">if</span> (state_ <span style="color:#666">==</span> blocked) {
        state_ <span style="color:#666">=</span> runnable;
        cpus[cpu_].enqueue(<span style="color:#007020;font-weight:bold">this</span>);
    }
    cpus[cpu_].runq_lock_.unlock(irqs);
}
</code></pre></div>
<h2 id="synchronization">Synchronization</h2>

<p>The separation of enqueuing and blocking is key to synchronization here. Let’s
enumerate how sleeping and waking up can interleave in this design; we’ll see
that every interleaving works OK.</p>

<ol>
<li><strong>The waking thread can run before <code>waiter::prepare</code>.</strong> No problem: the
sleeping thread will not block (it will call <code>break</code> to exit the while loop).</li>
<li><strong>The waking thread can run after <code>waiter::prepare</code>, but before
<code>waiter::block</code>.</strong> No problem: the waking thread resets the sleeping
thread’s <code>proc::state</code> to <code>runnable</code>, so the sleeping thread will not in
fact block (its <code>yield</code> call will keep it on the run queue).</li>
<li><strong>The waking thread can run after <code>waiter::block</code>.</strong> No problem: the waking
thread will wake up the sleeping thread as intended.</li>
</ol>

<p>The wait queue design implements its own synchronization (the <code>wait_queue</code> has
an embedded spinlock), and works correctly even if the sleeping and waking
threads don’t otherwise synchronize. But of course sleeping and waking threads
will often have other synchronization requirements and manipulate other
spinlocks, such as <code>ptable_lock</code>.</p>

<h2 id="tradeoffs">Tradeoffs</h2>

<p>Wait queues are not as integrated with core OS scheduling primitives as
blocking mechanisms in other kernels. That means we can imagine using other
mechanisms to block—if, for example, we want a fancy prioritized wait tree, we
can implement one. I value the insight that correct synchronization can be
obtained by <em>splitting</em> functionality into pieces, as well as by joining
functionality into an atomic step.</p>

<p>That said, the other kernels’ mechanisms are simpler to specify. (They are
just as hard to implement.)</p>

<p>Linux’s implementation of wait queues doesn’t lock as often as Chickadee’s
does. Linux developers have reasoned carefully about where locks are truly
necessary and where other synchronization primitives suffice.</p>

<p>True blocking is important, but we shouldn’t exaggerate its importance. Many
sensible sleep–wakeup mechanisms involve a mix of true blocking and kernel
polling (which is much better than user-level polling). This is because it can
be expensive and complex to create a wait queue or channel for every specific
condition a thread might block upon. Blocking can have high cost, in
complexity as well as in queue management and context switches.</p>

    </div>
</div>

        <script src="./lec08 -  Wait queues_files/jquery-3.3.1.slim.min.js" integrity="sha384-q8i/X+965DzO0rT7abK41JStQIAqVgRVzpbzo5smXKp4YfRvH+8abtTE1Pi6jizo" crossorigin="anonymous"></script>
        <script src="./lec08 -  Wait queues_files/popper.min.js" integrity="sha384-wHAiFfRlMFy6i5SRaxvfOCifBUQy1xHdJ/yoi7FRNXMRBu5WHdZYu1hA6ZOblgut" crossorigin="anonymous"></script>
        <script src="./lec08 -  Wait queues_files/bootstrap.min.js" integrity="sha384-B0UglyR+jN6CkvvICOB2joaf5I4l3gm9GU6Hc1og6Ls7i6U/mkkaduKaBhlAXv9k" crossorigin="anonymous"></script>
        <script src="./lec08 -  Wait queues_files/katex.min.js" integrity="sha384-K3vbOmF2BtaVai+Qk37uypf7VrgBubhQreNQe9aGsz9lB63dIFiQVlJbr92dw2Lx" crossorigin="anonymous"></script>
        <script>(function () {
        $(".math").each(function () {
            var t = this.innerText,
                opt = {throwOnError: false, displayMode: t.substr(0, 2) === "\\["};
            katex.render(t.replace(/(?:^\\\(|^\\\[|\\\)$|\\\]$)/g, ""), this, opt);
        });
        function sol_toggle(sol, hide, storage) {
            sol.childNodes[0].classList.toggle("hidden", !hide);
            sol.childNodes[0].classList.toggle("shown", hide);
            sol.childNodes[1].classList.toggle("hidden", hide);
            sol.childNodes[1].classList.toggle("shown", !hide);
            if (storage) {
                var key = location.href + " " + $(".has-solution").index(sol);
                if (hide)
                    sessionStorage.removeItem(key);
                else
                    sessionStorage.setItem(key, true);
            }
        }
        $(".solution").each(function () {
            $(this).wrap('<div class="has-solution"></div>');
            var sol = this.parentElement;
            $(sol).prepend('<blockquote class="solution-collapsed js-solution show"><a href="" class="js-solution show"></a></blockquote>');
            $(this).append('<p><a href="" class="js-solution hide"></a></p>');
            $(sol).find("a.js-solution.show").text(this.getAttribute("data-show-text") || "Show solution");
            $(sol).find("a.js-solution.hide").text(this.getAttribute("data-hide-text") || "Hide solution");
            var key = location.href + " " + $(".has-solution").index(sol);
            if (sessionStorage.getItem(key))
                sol_toggle(sol, false, false);
        });
        $(document).on("click", ".js-solution", function (event) {
            var sol = $(this).closest(".has-solution")[0];
            sol_toggle(sol, this.classList.contains("hide"), true);
            event.preventDefault();
        });
        })()</script>
    


</body></html>